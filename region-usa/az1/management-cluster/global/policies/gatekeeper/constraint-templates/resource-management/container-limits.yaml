# Container Limits
# Enforces maximum resource limits
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8scontainerlimits
  annotations:
    description: >-
      Enforces maximum CPU and memory limits for containers.
      Prevents individual containers from consuming excessive resources.
spec:
  crd:
    spec:
      names:
        kind: K8sContainerLimits
      validation:
        openAPIV3Schema:
          type: object
          properties:
            maxCpu:
              type: string
              description: Maximum CPU limit (e.g., "4", "4000m")
            maxMemory:
              type: string
              description: Maximum memory limit (e.g., "8Gi", "8192Mi")
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8scontainerlimits

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          container.resources.limits.cpu
          max_cpu := input.parameters.maxCpu
          cpu_exceeds_max(container.resources.limits.cpu, max_cpu)
          msg := sprintf("Container %v CPU limit %v exceeds maximum allowed %v", [container.name, container.resources.limits.cpu, max_cpu])
        }

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          container.resources.limits.memory
          max_memory := input.parameters.maxMemory
          memory_exceeds_max(container.resources.limits.memory, max_memory)
          msg := sprintf("Container %v memory limit %v exceeds maximum allowed %v", [container.name, container.resources.limits.memory, max_memory])
        }

        # Simple string comparison - for production use canonical_cpu/memory functions
        cpu_exceeds_max(cpu, max) {
          # This is a simplified check - consider using rego libraries for proper unit conversion
          to_number(trim_suffix(cpu, "m")) > to_number(trim_suffix(max, "m"))
        }

        memory_exceeds_max(memory, max) {
          # This is a simplified check - consider using rego libraries for proper unit conversion
          parse_memory(memory) > parse_memory(max)
        }

        parse_memory(mem) = result {
          endswith(mem, "Gi")
          result := to_number(trim_suffix(mem, "Gi")) * 1073741824
        }

        parse_memory(mem) = result {
          endswith(mem, "Mi")
          result := to_number(trim_suffix(mem, "Mi")) * 1048576
        }

        parse_memory(mem) = result {
          endswith(mem, "Ki")
          result := to_number(trim_suffix(mem, "Ki")) * 1024
        }

        parse_memory(mem) = result {
          not endswith(mem, "Gi")
          not endswith(mem, "Mi")
          not endswith(mem, "Ki")
          result := to_number(mem)
        }

