#!/bin/bash
#
# NKP Penetration Testing Tools Runner
# Installs and runs various Kubernetes security tools
#
# Usage:
#   ./scripts/run-pentest-tools.sh install                    # Install all tools
#   ./scripts/run-pentest-tools.sh kubescape --namespace <ns>  # Run kubescape
#   ./scripts/run-pentest-tools.sh kubeaudit --namespace <ns>  # Run kubeaudit
#   ./scripts/run-pentest-tools.sh trivy --namespace <ns>      # Run trivy
#   ./scripts/run-pentest-tools.sh all --namespace <ns>        # Run all tools
#

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default values
NAMESPACE=""
KUBECONFIG="${KUBECONFIG:-}"
OUTPUT_DIR="./pentest-tools-output-$(date +%Y%m%d-%H%M%S)"
EXCLUDE_NAMESPACES="kube-system,kube-public,kube-node-lease"

# Kubeconfig shortcuts function (uses environment variable or defaults)
get_kubeconfig() {
  # If KUBECONFIG is already set, use it
  if [ -n "${KUBECONFIG:-}" ]; then
    echo "$KUBECONFIG"
    return 0
  fi

  # Otherwise, use cluster shortcuts if provided
  case "$1" in
    mgmt)
      if [ -f "${HOME}/ws/nkp/dm-nkp-mgmt-1.conf" ]; then
        echo "${HOME}/ws/nkp/dm-nkp-mgmt-1.conf"
      else
        echo ""
      fi
      ;;
    workload1)
      if [ -f "${HOME}/ws/nkp/dm-nkp-workload-1.kubeconfig" ]; then
        echo "${HOME}/ws/nkp/dm-nkp-workload-1.kubeconfig"
      else
        echo ""
      fi
      ;;
    workload2)
      if [ -f "${HOME}/ws/nkp/dm-nkp-workload-2.kubeconfig" ]; then
        echo "${HOME}/ws/nkp/dm-nkp-workload-2.kubeconfig"
      else
        echo ""
      fi
      ;;
    *) echo "" ;;
  esac
}

# Logging
log() {
  local level=$1
  shift
  local message="$*"
  case $level in
    INFO) echo -e "${BLUE}[INFO]${NC} $message" ;;
    SUCCESS) echo -e "${GREEN}[SUCCESS]${NC} $message" ;;
    WARN) echo -e "${YELLOW}[WARN]${NC} $message" ;;
    ERROR) echo -e "${RED}[ERROR]${NC} $message" ;;
  esac
}

# Check if tool is installed
check_tool() {
  command -v "$1" >/dev/null 2>&1
}

# Install tool via brew
install_via_brew() {
  local tool=$1
  local brew_package=${2:-$tool}

  if check_tool "$tool"; then
    log SUCCESS "$tool is already installed"
    return 0
  fi

  log INFO "Installing $tool via Homebrew..."
  if brew install "$brew_package" 2>&1; then
    log SUCCESS "$tool installed successfully"
    return 0
  else
    log ERROR "Failed to install $tool via Homebrew"
    return 1
  fi
}

# Install kubescape
install_kubescape() {
  if check_tool kubescape; then
    log SUCCESS "kubescape is already installed"
    return 0
  fi

  log INFO "Installing kubescape..."
  if curl -s https://raw.githubusercontent.com/kubescape/kubescape/master/install.sh | /bin/bash 2>&1; then
    log SUCCESS "kubescape installed successfully"
    return 0
  else
    log ERROR "Failed to install kubescape"
    return 1
  fi
}

# Install kubeaudit
install_kubeaudit() {
  if check_tool kubeaudit; then
    log SUCCESS "kubeaudit is already installed"
    return 0
  fi

  # Try Homebrew first (note: deprecated but still works until 2026)
  log INFO "Installing kubeaudit via Homebrew (may show deprecation warning - tool still works)..."
  if brew install kubeaudit 2>&1; then
    log SUCCESS "kubeaudit installed successfully via Homebrew"
    log WARN "Note: kubeaudit is deprecated (archived upstream) but still functional until 2026-01-10"
    return 0
  else
    log ERROR "Failed to install kubeaudit via Homebrew"
    log INFO "Alternative installation methods:"
    log INFO "  1. Download binary from: https://github.com/Shopify/kubeaudit/releases"
    log INFO "  2. Or use kube-bench as replacement: brew install kube-bench"
    log WARN "Note: kubeaudit upstream repository is archived"
    return 1
  fi
}

# Install kube-hunter
install_kube_hunter() {
  if check_tool kube-hunter; then
    log SUCCESS "kube-hunter is already installed"
    return 0
  fi

  # Check for Python/pip3
  if ! command -v pip3 >/dev/null 2>&1 && ! command -v python3 >/dev/null 2>&1; then
    log WARN "Python3/pip3 not found. Trying alternative installation methods..."

    # Try Homebrew to install Python first
    if command -v brew >/dev/null 2>&1; then
      log INFO "Installing Python via Homebrew (required for kube-hunter)..."
      if brew install python@3 2>&1; then
        log SUCCESS "Python installed, retrying kube-hunter installation..."
      else
        log ERROR "Failed to install Python via Homebrew"
        log INFO "Alternative: kube-hunter can be run via Docker:"
        log INFO "  docker run -it --rm aquasec/kube-hunter --remote <api-server-ip>"
        return 1
      fi
    else
      log ERROR "Homebrew not available. Cannot install Python automatically."
      log INFO "Please install Python3 manually:"
      log INFO "  brew install python@3"
      log INFO "  Or: Download from https://www.python.org/downloads/"
      log INFO ""
      log INFO "Alternative: kube-hunter can be run via Docker:"
      log INFO "  docker run -it --rm aquasec/kube-hunter --remote <api-server-ip>"
      return 1
    fi
  fi

  # Now try pip3 install (use python3 -m pip if pip3 not directly available)
  local pip_cmd="pip3"
  if ! command -v pip3 >/dev/null 2>&1 && command -v python3 >/dev/null 2>&1; then
    pip_cmd="python3 -m pip"
    log INFO "Using python3 -m pip instead of pip3"
  fi

  log INFO "Installing kube-hunter via $pip_cmd..."
  if $pip_cmd install kube-hunter 2>&1; then
    log SUCCESS "kube-hunter installed successfully"
    return 0
  else
    log WARN "Failed to install kube-hunter via pip, but you can still run it via Docker"
    log INFO "The run command will automatically use Docker if kube-hunter is not installed"
    log INFO "Alternative installation methods:"
    log INFO "  1. Run via Docker (automatic fallback): docker run --rm aquasec/kube-hunter --remote <api-server-ip>"
    log INFO "  2. Install Python manually: brew install python@3"
    log INFO "  3. Use as Kubernetes job (see documentation)"
    # Don't fail - Docker fallback will work
    return 0
  fi
}

# Install kube-bench
install_kube_bench() {
  if check_tool kube-bench; then
    log SUCCESS "kube-bench is already installed"
    return 0
  fi

  log INFO "Installing kube-bench..."
  local version="v0.6.9"
  local arch="amd64"
  if [[ $(uname -m) == "arm64" ]]; then
    arch="arm64"
  fi

  local url="https://github.com/aquasecurity/kube-bench/releases/download/${version}/kube-bench_${version}_darwin_${arch}.tar.gz"

  if curl -L "$url" -o /tmp/kube-bench.tar.gz 2>&1 && \
     tar -xzf /tmp/kube-bench.tar.gz -C /tmp 2>&1 && \
     sudo mv /tmp/kube-bench /usr/local/bin/ 2>&1; then
    log SUCCESS "kube-bench installed successfully"
    rm -f /tmp/kube-bench.tar.gz
    return 0
  else
    log ERROR "Failed to install kube-bench"
    return 1
  fi
}

# Install all tools
install_all() {
  log INFO "Installing all penetration testing tools..."

  local failed=0

  install_via_brew trivy trivy || failed=$((failed + 1))
  install_kubescape || failed=$((failed + 1))
  install_kubeaudit || failed=$((failed + 1))
  install_via_brew polaris polaris || failed=$((failed + 1))
  install_via_brew checkov checkov || failed=$((failed + 1))
  install_kube_hunter || failed=$((failed + 1))
  install_kube_bench || failed=$((failed + 1))

  if [ $failed -eq 0 ]; then
    log SUCCESS "All tools installed successfully!"
  else
    log WARN "$failed tool(s) failed to install. Some tools may need manual installation."
  fi

  log INFO "Note: Ensure ~/go/bin is in your PATH for kubeaudit"
  log INFO "Add to ~/.zshrc: export PATH=\$PATH:\$HOME/go/bin"
}

# Set kubeconfig
set_kubeconfig() {
  # If KUBECONFIG is already set in environment, use it (highest priority)
  if [ -n "${KUBECONFIG:-}" ] && [ -z "${1:-}" ]; then
    log INFO "Using KUBECONFIG from environment: $KUBECONFIG"
    return 0
  fi

  # If cluster shortcut provided, try to resolve it
  if [ -n "${1:-}" ]; then
    local kc_path=$(get_kubeconfig "$1")
    if [ -n "$kc_path" ] && [ -f "$kc_path" ]; then
      export KUBECONFIG="$kc_path"
      log INFO "Using kubeconfig: $1 -> $kc_path"
    else
      log WARN "Cluster shortcut '$1' not found, using KUBECONFIG from environment if set"
    fi
  fi

  # If KUBECONFIG is set (from env or shortcut), verify it exists
  if [ -n "${KUBECONFIG:-}" ] && [ ! -f "$KUBECONFIG" ]; then
    log WARN "KUBECONFIG file not found: $KUBECONFIG"
    log INFO "Using default kubectl context"
  fi
}

# Run kubescape
run_kubescape() {
  if ! check_tool kubescape; then
    log ERROR "kubescape is not installed. Run: $0 install"
    return 1
  fi

  log INFO "Running kubescape..."
  mkdir -p "$OUTPUT_DIR"

  local include_flag=""
  local exclude_flag="--exclude-namespaces $EXCLUDE_NAMESPACES"

  if [ -n "$NAMESPACE" ]; then
    include_flag="--include-namespaces $NAMESPACE"
    exclude_flag=""
  fi

  # Framework scan
  log INFO "Running NSA framework scan..."
  kubescape scan framework nsa $include_flag $exclude_flag \
    --format json --output "$OUTPUT_DIR/kubescape-nsa.json" 2>&1 || true
  kubescape scan framework nsa $include_flag $exclude_flag \
    --format html --output "$OUTPUT_DIR/kubescape-nsa.html" 2>&1 || true

  # MITRE scan
  log INFO "Running MITRE framework scan..."
  kubescape scan framework mitre $include_flag $exclude_flag \
    --format json --output "$OUTPUT_DIR/kubescape-mitre.json" 2>&1 || true

  # CVE scan
  log INFO "Running CVE scan..."
  kubescape scan cve $include_flag $exclude_flag \
    --format json --output "$OUTPUT_DIR/kubescape-cve.json" 2>&1 || true

  log SUCCESS "kubescape results saved to $OUTPUT_DIR/kubescape-*.{json,html}"
}

# Run kubeaudit
run_kubeaudit() {
  if ! check_tool kubeaudit; then
    log ERROR "kubeaudit is not installed. Run: $0 install"
    log INFO "Or install manually: go install github.com/Shopify/kubeaudit@latest"
    return 1
  fi

  log INFO "Running kubeaudit..."
  mkdir -p "$OUTPUT_DIR"

  local ns_flag=""
  if [ -n "$NAMESPACE" ]; then
    ns_flag="-n $NAMESPACE"
  fi

  kubeaudit all $ns_flag > "$OUTPUT_DIR/kubeaudit-all.txt" 2>&1 || true

  # Run autofix checks
  log INFO "Running kubeaudit autofix checks..."
  kubeaudit autofix runAsNonRoot $ns_flag > "$OUTPUT_DIR/kubeaudit-autofix-nonroot.txt" 2>&1 || true
  kubeaudit autofix readOnlyRootFilesystem $ns_flag > "$OUTPUT_DIR/kubeaudit-autofix-readonly.txt" 2>&1 || true

  log SUCCESS "kubeaudit results saved to $OUTPUT_DIR/kubeaudit-*.txt"
}

# Run trivy
run_trivy() {
  if ! check_tool trivy; then
    log ERROR "trivy is not installed. Run: $0 install"
    return 1
  fi

  log INFO "Running trivy..."
  mkdir -p "$OUTPUT_DIR"

  # Trivy uses --include-namespaces flag
  local ns_flag=""
  if [ -n "$NAMESPACE" ]; then
    ns_flag="--include-namespaces $NAMESPACE"
  fi

  # Cluster scan
  log INFO "Running trivy cluster scan..."
  trivy k8s cluster $ns_flag --severity HIGH,CRITICAL \
    --format json --output "$OUTPUT_DIR/trivy-cluster.json" 2>&1 || true
  trivy k8s cluster $ns_flag --severity HIGH,CRITICAL \
    --format table > "$OUTPUT_DIR/trivy-cluster.txt" 2>&1 || true

  log SUCCESS "trivy results saved to $OUTPUT_DIR/trivy-*.{json,txt}"
}

# Run kube-hunter
run_kube_hunter() {
  mkdir -p "$OUTPUT_DIR"

  # Get API server endpoint
  local api_server=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}' 2>/dev/null || echo "")

  if [ -z "$api_server" ]; then
    log ERROR "Could not determine API server endpoint"
    log INFO "Make sure KUBECONFIG is set or use --kubeconfig flag"
    return 1
  fi

  # Extract hostname/IP from API server URL (remove https:// and port)
  local api_host=$(echo "$api_server" | sed 's|https\?://||' | sed 's|:.*||')

  log INFO "API Server: $api_server"
  log INFO "Target Host: $api_host"

  # Try native kube-hunter first
  if check_tool kube-hunter; then
    log INFO "Running kube-hunter (native installation) in remote mode..."
    log WARN "Note: Remote mode requires API server to be accessible from your network"
    kube-hunter --remote "$api_host" --report json --log WARNING \
      > "$OUTPUT_DIR/kube-hunter.json" 2>&1 || true
    kube-hunter --remote "$api_host" --report plain --log WARNING \
      > "$OUTPUT_DIR/kube-hunter.txt" 2>&1 || true

    # Check if scan found anything
    if grep -q "couldn't find any clusters\|No vulnerabilities were found" "$OUTPUT_DIR/kube-hunter.txt" 2>/dev/null; then
      log WARN "kube-hunter couldn't find clusters - API server may not be accessible externally"
      log INFO "This is GOOD for security, but means remote scan can't test externally exposed services"
      log INFO "Consider running kube-hunter as a pod inside the cluster for internal testing"
    fi

    log SUCCESS "kube-hunter results saved to $OUTPUT_DIR/kube-hunter.{json,txt}"
    return 0
  fi

  # Fall back to Docker if available
  if command -v docker >/dev/null 2>&1; then
    log INFO "kube-hunter not installed, running via Docker..."
    log WARN "Note: Remote mode requires API server to be accessible from Docker network"
    log INFO "Scanning API server: $api_host"

    # Try with platform flag for ARM Macs
    local platform_flag=""
    if [[ $(uname -m) == "arm64" ]]; then
      platform_flag="--platform linux/amd64"
      log INFO "Using --platform linux/amd64 for ARM Mac compatibility"
    fi

    # Run scan
    docker run $platform_flag --rm aquasec/kube-hunter \
      --remote "$api_host" --report json --log WARNING \
      > "$OUTPUT_DIR/kube-hunter.json" 2>&1 || true
    docker run $platform_flag --rm aquasec/kube-hunter \
      --remote "$api_host" --report plain --log WARNING \
      > "$OUTPUT_DIR/kube-hunter.txt" 2>&1 || true

    # Check if scan found anything
    if grep -q "couldn't find any clusters\|No vulnerabilities were found" "$OUTPUT_DIR/kube-hunter.txt" 2>/dev/null; then
      log WARN "kube-hunter couldn't find clusters - API server may not be accessible externally"
      log INFO "This is GOOD for security - your API server is not exposed to external networks"
      log INFO ""
      log INFO "To test internal security, run kube-hunter as a pod inside the cluster:"
      log INFO "  kubectl run kube-hunter --image=aquasec/kube-hunter --rm -it --restart=Never -- \\"
      log INFO "    python kubehunter.py --pod --report json"
      log INFO ""
      log INFO "Or use active scanning (requires API server to be accessible):"
      log INFO "  docker run $platform_flag --rm aquasec/kube-hunter --remote $api_host --active"
    fi

    log SUCCESS "kube-hunter results saved to $OUTPUT_DIR/kube-hunter.{json,txt}"
    return 0
  fi

  # If neither works, provide instructions
  log ERROR "kube-hunter is not installed and Docker is not available"
  log INFO "Installation options:"
  log INFO "  1. Install Python and kube-hunter:"
  log INFO "     brew install python@3"
  log INFO "     pip3 install kube-hunter"
  log INFO "  2. Install Docker and run:"
  log INFO "     docker run --rm aquasec/kube-hunter --remote $api_host"
  log INFO "  3. Run as Kubernetes job (see documentation)"
  return 1
}

# Run kube-hunter as a pod inside the cluster (better for internal testing)
run_kube_hunter_pod() {
  mkdir -p "$OUTPUT_DIR"

  log INFO "Running kube-hunter as a pod inside the cluster (internal testing)..."
  log INFO "This tests security from inside the cluster (simulates compromised pod)"

  # Create a job to run kube-hunter
  local job_name="kube-hunter-scan-$(date +%s)"
  local ns_flag=""
  if [ -n "$NAMESPACE" ]; then
    ns_flag="-n $NAMESPACE"
  else
    ns_flag="-n default"
  fi

  log INFO "Creating kube-hunter job: $job_name"

  # Create job YAML
  cat <<EOF | kubectl apply -f - 2>&1
apiVersion: batch/v1
kind: Job
metadata:
  name: $job_name
  $ns_flag
spec:
  ttlSecondsAfterFinished: 300
  template:
    spec:
      restartPolicy: Never
      containers:
      - name: kube-hunter
        image: aquasec/kube-hunter:latest
        command: ["python", "kubehunter.py", "--pod", "--report", "json"]
        securityContext:
          runAsNonRoot: true
          allowPrivilegeEscalation: false
          capabilities:
            drop:
              - ALL
      terminationGracePeriodSeconds: 30
EOF

  log INFO "Waiting for job to complete (this may take a few minutes)..."
  kubectl wait --for=condition=complete --timeout=5m job/$job_name $ns_flag 2>&1 || true

  # Get logs
  log INFO "Retrieving kube-hunter results..."
  kubectl logs job/$job_name $ns_flag > "$OUTPUT_DIR/kube-hunter-pod.json" 2>&1 || true

  # Also get plain text output
  kubectl run kube-hunter-txt-$job_name --image=aquasec/kube-hunter:latest \
    --rm -i --restart=Never $ns_flag -- \
    python kubehunter.py --pod --report plain \
    > "$OUTPUT_DIR/kube-hunter-pod.txt" 2>&1 || true

  # Cleanup
  log INFO "Cleaning up job..."
  kubectl delete job $job_name $ns_flag --ignore-not-found=true 2>&1 || true

  log SUCCESS "kube-hunter pod results saved to $OUTPUT_DIR/kube-hunter-pod.{json,txt}"
  log INFO "This scan tests internal cluster security (from inside the cluster)"
}

# Run kube-bench
run_kube_bench() {
  if ! check_tool kube-bench; then
    log ERROR "kube-bench is not installed. Run: $0 install"
    return 1
  fi

  log INFO "Running kube-bench..."
  mkdir -p "$OUTPUT_DIR"

  # Note: kube-bench needs to run on the nodes, not via kubectl
  log WARN "kube-bench must be run directly on cluster nodes"
  log INFO "To run kube-bench:"
  echo "  1. SSH into a master node"
  echo "  2. Run: kube-bench master"
  echo "  3. SSH into a worker node"
  echo "  4. Run: kube-bench node"
  echo ""
  echo "Or run as a Kubernetes job (see kube-bench documentation)"
}

# Run polaris
run_polaris() {
  if ! check_tool polaris; then
    log ERROR "polaris is not installed. Run: $0 install"
    return 1
  fi

  log INFO "Running polaris..."
  mkdir -p "$OUTPUT_DIR"

  # Polaris scans manifests, not live cluster
  log INFO "Polaris scans YAML manifests. Exporting cluster resources..."

  local ns_flag=""
  if [ -n "$NAMESPACE" ]; then
    ns_flag="-n $NAMESPACE"
    kubectl get all $ns_flag -o yaml > "$OUTPUT_DIR/polaris-resources.yaml" 2>&1
    polaris audit --audit-path "$OUTPUT_DIR/polaris-resources.yaml" \
      --output-format json --output-file "$OUTPUT_DIR/polaris.json" 2>&1 || true
    polaris audit --audit-path "$OUTPUT_DIR/polaris-resources.yaml" \
      --output-format score --output-file "$OUTPUT_DIR/polaris-score.txt" 2>&1 || true
  else
    log WARN "Polaris requires namespace scope or manifest files"
    log INFO "To scan all namespaces, export resources first:"
    echo "  kubectl get all --all-namespaces -o yaml > resources.yaml"
    echo "  polaris audit --audit-path resources.yaml"
  fi

  log SUCCESS "polaris results saved to $OUTPUT_DIR/polaris-*.{json,txt}"
}

# Run checkov
run_checkov() {
  if ! check_tool checkov; then
    log ERROR "checkov is not installed. Run: $0 install"
    return 1
  fi

  log INFO "Running checkov..."
  mkdir -p "$OUTPUT_DIR"

  # Checkov scans infrastructure as code, not live cluster
  log INFO "Exporting cluster resources for checkov analysis..."

  local ns_flag=""
  if [ -n "$NAMESPACE" ]; then
    ns_flag="-n $NAMESPACE"
    kubectl get all $ns_flag -o yaml > "$OUTPUT_DIR/checkov-resources.yaml" 2>&1
    checkov -f "$OUTPUT_DIR/checkov-resources.yaml" --framework kubernetes \
      --output json --output-file-path "$OUTPUT_DIR" 2>&1 || true
    checkov -f "$OUTPUT_DIR/checkov-resources.yaml" --framework kubernetes \
      --output cli > "$OUTPUT_DIR/checkov.txt" 2>&1 || true
  else
    log WARN "Checkov requires namespace scope or manifest files"
    log INFO "To scan all namespaces, export resources first:"
    echo "  kubectl get all --all-namespaces -o yaml > resources.yaml"
    echo "  checkov -f resources.yaml --framework kubernetes"
  fi

  log SUCCESS "checkov results saved to $OUTPUT_DIR/checkov-*.{json,txt}"
}

# Run all tools
run_all() {
  log INFO "Running all penetration testing tools..."
  mkdir -p "$OUTPUT_DIR"

  run_kubescape || log WARN "kubescape failed"
  run_kubeaudit || log WARN "kubeaudit failed"
  run_trivy || log WARN "trivy failed"
  run_kube_hunter || log WARN "kube-hunter failed"
  run_polaris || log WARN "polaris failed"
  run_checkov || log WARN "checkov failed"

  log SUCCESS "All tools completed. Results in: $OUTPUT_DIR"
}

# Show help
show_help() {
  cat << EOF
NKP Penetration Testing Tools Runner

Usage:
  $0 <command> [options]

Commands:
  install                    Install all tools
  kubescape                  Run kubescape scans
  kubeaudit                  Run kubeaudit security audit
  trivy                      Run trivy vulnerability scanner
  kube-hunter                Run kube-hunter security hunter (remote mode - requires API server access)
  kube-hunter-pod            Run kube-hunter as pod inside cluster (internal testing - recommended)
  kube-bench                 Show kube-bench instructions (runs on nodes)
  polaris                    Run polaris configuration validation
  checkov                    Run checkov infrastructure scanning
  all                        Run all tools
  help                       Show this help message

Options:
  --namespace <ns>           Target specific namespace
  --kubeconfig <path>        Path to kubeconfig file
  --cluster <name>           Use predefined cluster (mgmt, workload1, workload2)
  --output <dir>             Output directory (default: ./pentest-tools-output-TIMESTAMP)
  --exclude-ns <ns1,ns2>     Exclude namespaces (default: kube-system,kube-public,kube-node-lease)

Examples:
  # Install all tools
  $0 install

  # Run kubescape on specific namespace
  $0 kubescape --namespace dm-dev-workspace

  # Run kubeaudit on management cluster
  $0 kubeaudit --cluster mgmt --namespace kommander

  # Run all tools on a namespace
  $0 all --namespace dm-dev-workspace --cluster workload1

  # Run trivy with custom kubeconfig
  $0 trivy --kubeconfig /path/to/kubeconfig --namespace default

Predefined Clusters (optional shortcuts, uses KUBECONFIG env var if set):
  mgmt       -> ~/ws/nkp/dm-nkp-mgmt-1.conf (if exists)
  workload1  -> ~/ws/nkp/dm-nkp-workload-1.kubeconfig (if exists)
  workload2  -> ~/ws/nkp/dm-nkp-workload-2.kubeconfig (if exists)

Note: The script prioritizes KUBECONFIG environment variable over shortcuts.
      Set KUBECONFIG before running: export KUBECONFIG=/path/to/kubeconfig

EOF
}

# Parse arguments
COMMAND=""
while [[ $# -gt 0 ]]; do
  case $1 in
    install|kubescape|kubeaudit|trivy|kube-hunter|kube-bench|polaris|checkov|all|help)
      COMMAND="$1"
      shift
      ;;
    --namespace|-n)
      NAMESPACE="$2"
      shift 2
      ;;
    --kubeconfig|-k)
      KUBECONFIG="$2"
      export KUBECONFIG
      shift 2
      ;;
    --cluster|-c)
      set_kubeconfig "$2"
      shift 2
      ;;
    --output|-o)
      OUTPUT_DIR="$2"
      shift 2
      ;;
    --exclude-ns)
      EXCLUDE_NAMESPACES="$2"
      shift 2
      ;;
    --help|-h)
      show_help
      exit 0
      ;;
    *)
      echo "Unknown option: $1"
      show_help
      exit 1
      ;;
  esac
done

# Execute command
case "$COMMAND" in
  install)
    install_all
    ;;
  kubescape)
    run_kubescape
    ;;
  kubeaudit)
    run_kubeaudit
    ;;
  trivy)
    run_trivy
    ;;
  kube-hunter)
    run_kube_hunter
    ;;
  kube-hunter-pod)
    run_kube_hunter_pod
    ;;
  kube-bench)
    run_kube_bench
    ;;
  polaris)
    run_polaris
    ;;
  checkov)
    run_checkov
    ;;
  all)
    run_all
    ;;
  help|"")
    show_help
    ;;
  *)
    echo "Unknown command: $COMMAND"
    show_help
    exit 1
    ;;
esac

